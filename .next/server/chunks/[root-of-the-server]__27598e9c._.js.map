{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/phanu/Automation-n8n%2Bwebiste/Automation-n8n%2Bwebiste/src/lib/webhook-security.ts"],"sourcesContent":["import crypto from 'crypto';\n\n// Webhook secret - in production, store in environment variables\nconst WEBHOOK_SECRET = process.env.WEBHOOK_SECRET || 'boom-portfolio-webhook-secret-2024';\n\n/**\n * Generate HMAC signature for webhook payload\n */\nexport function generateSignature(payload: string): string {\n  return crypto\n    .createHmac('sha256', WEBHOOK_SECRET)\n    .update(payload, 'utf8')\n    .digest('hex');\n}\n\n/**\n * Verify webhook signature\n */\nexport function verifySignature(payload: string, signature: string): boolean {\n  const expectedSignature = generateSignature(payload);\n  \n  // Use crypto.timingSafeEqual to prevent timing attacks\n  const expectedBuffer = Buffer.from(`sha256=${expectedSignature}`, 'utf8');\n  const actualBuffer = Buffer.from(signature, 'utf8');\n  \n  if (expectedBuffer.length !== actualBuffer.length) {\n    return false;\n  }\n  \n  return crypto.timingSafeEqual(expectedBuffer, actualBuffer);\n}\n\n/**\n * Generate signature header for outgoing webhooks\n */\nexport function createSignatureHeader(payload: string): string {\n  return `sha256=${generateSignature(payload)}`;\n}\n\n/**\n * Validate incoming webhook request\n */\nexport function validateWebhookRequest(\n  payload: string, \n  signatureHeader: string | null\n): { valid: boolean; error?: string } {\n  if (!signatureHeader) {\n    return { valid: false, error: 'Missing signature header' };\n  }\n\n  if (!signatureHeader.startsWith('sha256=')) {\n    return { valid: false, error: 'Invalid signature format' };\n  }\n\n  const isValid = verifySignature(payload, signatureHeader);\n  \n  if (!isValid) {\n    return { valid: false, error: 'Invalid signature' };\n  }\n\n  return { valid: true };\n}\n\n/**\n * Generate session-based token for additional security\n */\nexport function generateSessionToken(sessionId: string): string {\n  const timestamp = Date.now().toString();\n  const data = `${sessionId}:${timestamp}`;\n  const signature = crypto\n    .createHmac('sha256', WEBHOOK_SECRET)\n    .update(data, 'utf8')\n    .digest('hex');\n  \n  return `${timestamp}.${signature}`;\n}\n\n/**\n * Verify session token (valid for 1 hour)\n */\nexport function verifySessionToken(sessionId: string, token: string): boolean {\n  try {\n    const [timestamp, signature] = token.split('.');\n    \n    if (!timestamp || !signature) {\n      return false;\n    }\n\n    // Check if token is not older than 1 hour\n    const tokenTime = parseInt(timestamp);\n    const now = Date.now();\n    const oneHour = 60 * 60 * 1000;\n    \n    if (now - tokenTime > oneHour) {\n      return false;\n    }\n\n    // Verify signature\n    const data = `${sessionId}:${timestamp}`;\n    const expectedSignature = crypto\n      .createHmac('sha256', WEBHOOK_SECRET)\n      .update(data, 'utf8')\n      .digest('hex');\n\n    return crypto.timingSafeEqual(\n      Buffer.from(signature, 'hex'),\n      Buffer.from(expectedSignature, 'hex')\n    );\n  } catch (error) {\n    return false;\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAEA,iEAAiE;AACjE,MAAM,iBAAiB,QAAQ,GAAG,CAAC,cAAc,IAAI;AAK9C,SAAS,kBAAkB,OAAe;IAC/C,OAAO,qGAAA,CAAA,UAAM,CACV,UAAU,CAAC,UAAU,gBACrB,MAAM,CAAC,SAAS,QAChB,MAAM,CAAC;AACZ;AAKO,SAAS,gBAAgB,OAAe,EAAE,SAAiB;IAChE,MAAM,oBAAoB,kBAAkB;IAE5C,uDAAuD;IACvD,MAAM,iBAAiB,OAAO,IAAI,CAAC,CAAC,OAAO,EAAE,mBAAmB,EAAE;IAClE,MAAM,eAAe,OAAO,IAAI,CAAC,WAAW;IAE5C,IAAI,eAAe,MAAM,KAAK,aAAa,MAAM,EAAE;QACjD,OAAO;IACT;IAEA,OAAO,qGAAA,CAAA,UAAM,CAAC,eAAe,CAAC,gBAAgB;AAChD;AAKO,SAAS,sBAAsB,OAAe;IACnD,OAAO,CAAC,OAAO,EAAE,kBAAkB,UAAU;AAC/C;AAKO,SAAS,uBACd,OAAe,EACf,eAA8B;IAE9B,IAAI,CAAC,iBAAiB;QACpB,OAAO;YAAE,OAAO;YAAO,OAAO;QAA2B;IAC3D;IAEA,IAAI,CAAC,gBAAgB,UAAU,CAAC,YAAY;QAC1C,OAAO;YAAE,OAAO;YAAO,OAAO;QAA2B;IAC3D;IAEA,MAAM,UAAU,gBAAgB,SAAS;IAEzC,IAAI,CAAC,SAAS;QACZ,OAAO;YAAE,OAAO;YAAO,OAAO;QAAoB;IACpD;IAEA,OAAO;QAAE,OAAO;IAAK;AACvB;AAKO,SAAS,qBAAqB,SAAiB;IACpD,MAAM,YAAY,KAAK,GAAG,GAAG,QAAQ;IACrC,MAAM,OAAO,GAAG,UAAU,CAAC,EAAE,WAAW;IACxC,MAAM,YAAY,qGAAA,CAAA,UAAM,CACrB,UAAU,CAAC,UAAU,gBACrB,MAAM,CAAC,MAAM,QACb,MAAM,CAAC;IAEV,OAAO,GAAG,UAAU,CAAC,EAAE,WAAW;AACpC;AAKO,SAAS,mBAAmB,SAAiB,EAAE,KAAa;IACjE,IAAI;QACF,MAAM,CAAC,WAAW,UAAU,GAAG,MAAM,KAAK,CAAC;QAE3C,IAAI,CAAC,aAAa,CAAC,WAAW;YAC5B,OAAO;QACT;QAEA,0CAA0C;QAC1C,MAAM,YAAY,SAAS;QAC3B,MAAM,MAAM,KAAK,GAAG;QACpB,MAAM,UAAU,KAAK,KAAK;QAE1B,IAAI,MAAM,YAAY,SAAS;YAC7B,OAAO;QACT;QAEA,mBAAmB;QACnB,MAAM,OAAO,GAAG,UAAU,CAAC,EAAE,WAAW;QACxC,MAAM,oBAAoB,qGAAA,CAAA,UAAM,CAC7B,UAAU,CAAC,UAAU,gBACrB,MAAM,CAAC,MAAM,QACb,MAAM,CAAC;QAEV,OAAO,qGAAA,CAAA,UAAM,CAAC,eAAe,CAC3B,OAAO,IAAI,CAAC,WAAW,QACvB,OAAO,IAAI,CAAC,mBAAmB;IAEnC,EAAE,OAAO,OAAO;QACd,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 153, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/phanu/Automation-n8n%2Bwebiste/Automation-n8n%2Bwebiste/src/app/api/chatreport/route.ts"],"sourcesContent":["//chatreport\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { createSignatureHeader, generateSessionToken } from \"@/lib/webhook-security\";\n\n// Portfolio data for the AI to reference\nconst portfolioData = {\n  name: \"์NIS Automation AI Report\",\n  title: \"AI Report\",\n  contact: {\n    phone: \"(+66) 85-835-1266\",\n    email: \"Phanupong_C@npp.co.th\",\n    address: \"1 tatoom, Srimahapot, Prachin buri 25140, Thailand\"\n  },\n};\n\nexport async function POST(request: NextRequest) {\n  let userMessage = \"\";\n  let sessionId = \"\";\n\n  try {\n    const { message, history, sessionId: clientSessionId } = await request.json();\n    userMessage = message || \"\";\n    sessionId = clientSessionId || `session_${Date.now()}`;\n\n    if (!userMessage) {\n      return NextResponse.json(\n        { error: \"Message is required\" },\n        { status: 400 }\n      );\n    }\n\n    console.log(`[Chat API] Session: ${sessionId}, Message: ${userMessage.substring(0, 50)}...`);\n\n    // Try to send to n8n webhook first\n    try {\n      const payload = JSON.stringify({\n        message: userMessage,\n        history,\n        portfolioData,\n        sessionId,\n        responseUrl: `http://localhost:3001/api/webhook`,\n        sessionToken: generateSessionToken(sessionId),\n        timestamp: new Date().toISOString()\n      });\n\n      const signature = createSignatureHeader(payload);\n\n      const webhookResponse = await fetch(\"http://localhost:5678/webhook/8bdc9363-b386-44cb-a05c-cd168d0f8608\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"x-session-id\": sessionId,\n          \"x-webhook-source\": \"portfolio-chat\",\n          \"x-signature\": signature,\n        },\n        body: payload,\n        // Add timeout to prevent hanging\n        signal: AbortSignal.timeout(15000) // 15 second timeout\n      });\n\n      if (webhookResponse.ok) {\n        const webhookData = await webhookResponse.json();\n        console.log(`[Chat API] Webhook success for session ${sessionId}:`, webhookData);\n\n        // Check if n8n will send response via webhook (async mode)\n        if (webhookData.useSSE || webhookData.async || webhookData.status === 'processing' ||\n            (webhookData.message && webhookData.message.includes('Workflow was started'))) {\n          console.log(`[Chat API] Using SSE mode for session ${sessionId} - n8n will send response later`);\n          return NextResponse.json({\n            success: true,\n            useSSE: true,\n            sessionId,\n            message: \"Response will be sent via real-time connection\"\n          });\n        }\n\n        // Handle immediate response formats\n        let responseMessage = \"\";\n        if (typeof webhookData === 'string') {\n          responseMessage = webhookData;\n        } else if (webhookData.response) {\n          responseMessage = webhookData.response;\n        } else if (webhookData.message) {\n          responseMessage = webhookData.message;\n        } else if (webhookData.reply) {\n          responseMessage = webhookData.reply;\n        } else if (webhookData.text) {\n          responseMessage = webhookData.text;\n        } else {\n          // If webhook returns unexpected format, log it and use fallback\n          console.log(`[Chat API] Unexpected webhook response format:`, webhookData);\n          console.log(`[Chat API] Using fallback response for session ${sessionId}`);\n          throw new Error(\"Unexpected webhook response format\");\n        }\n\n        console.log(`[Chat API] Immediate response for session ${sessionId}:`, responseMessage);\n        return NextResponse.json({ message: responseMessage, useSSE: false });\n      } else {\n        const errorText = await webhookResponse.text();\n        console.log(`[Chat API] Webhook error ${webhookResponse.status}:`, errorText);\n        throw new Error(`Webhook returned status: ${webhookResponse.status}`);\n      }\n    } catch (webhookError) {\n      console.log(`[Chat API] Webhook failed for session ${sessionId}, using fallback:`, webhookError);\n      // Fallback to local response if webhook fails\n      const response = generateResponse(userMessage.toLowerCase());\n      console.log(`[Chat API] Fallback response for session ${sessionId}:`, response.substring(0, 100) + \"...\");\n      return NextResponse.json({\n        message: response,\n        useSSE: false,\n        fallback: true\n      });\n    }\n  } catch (error) {\n    console.error(`[Chat API] Final error for session ${sessionId}:`, error);\n    // Final fallback\n    const response = generateResponse(userMessage.toLowerCase() || \"\");\n    console.log(`[Chat API] Final fallback response for session ${sessionId}:`, response.substring(0, 100) + \"...\");\n    return NextResponse.json({\n      message: response,\n      useSSE: false,\n      fallback: true,\n      error: \"System temporarily unavailable\"\n    });\n  }\n}\n\nfunction generateResponse(message: string): string { //ตอบเมื่อ n8n ล่ม\n  // Contact-related queries\n  if (message.includes(\"contact\") || message.includes(\"email\") || message.includes(\"phone\") || message.includes(\"reach\") || message.includes(\"ติดต่อ\")) {\n    return `ขณะนี้ระบบตอบคำถามอัจฉริยะขัดข้อง คุณสามารถติดต่อทีม Instrument service ได้ที่:\n    📧 Email: ${portfolioData.contact.email}\n    📱 Phone: ${portfolioData.contact.phone}\n\n  เรายินดีให้คำปรึกษาและออกแบบบริการตรวจสอบ/ซ่อมบำรุงให้เหมาะกับโรงงานหรือหน่วยงานของคุณ!`;\n  }\n\n  // Default fallback\n  return `ขอบคุณสำหรับคำถามครับ! ขณะนี้ระบบตอบคำถามอัจฉริยะขัดข้อง หากคุณสนใจเรื่องงานซ่อมบำรุง วาล์ว เซฟตี้วาล์ว แท่นชั่งดิจิทัล ระบบวัดอัตราการไหล หรือ IoT สามารถติดต่อช่องทางดังนี้ได้เลยครับ😀\n\n  📧 Email: ${portfolioData.contact.email}, \n  📱 Phone: ${portfolioData.contact.phone}\n  `;\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}