{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/phanu/BoomBigNose-n8n%2Bwebiste/BoomBigNose-portfolio/src/lib/webhook-security.ts"],"sourcesContent":["import crypto from 'crypto';\n\n// Webhook secret - in production, store in environment variables\nconst WEBHOOK_SECRET = process.env.WEBHOOK_SECRET || 'boom-portfolio-webhook-secret-2024';\n\n/**\n * Generate HMAC signature for webhook payload\n */\nexport function generateSignature(payload: string): string {\n  return crypto\n    .createHmac('sha256', WEBHOOK_SECRET)\n    .update(payload, 'utf8')\n    .digest('hex');\n}\n\n/**\n * Verify webhook signature\n */\nexport function verifySignature(payload: string, signature: string): boolean {\n  const expectedSignature = generateSignature(payload);\n  \n  // Use crypto.timingSafeEqual to prevent timing attacks\n  const expectedBuffer = Buffer.from(`sha256=${expectedSignature}`, 'utf8');\n  const actualBuffer = Buffer.from(signature, 'utf8');\n  \n  if (expectedBuffer.length !== actualBuffer.length) {\n    return false;\n  }\n  \n  return crypto.timingSafeEqual(expectedBuffer, actualBuffer);\n}\n\n/**\n * Generate signature header for outgoing webhooks\n */\nexport function createSignatureHeader(payload: string): string {\n  return `sha256=${generateSignature(payload)}`;\n}\n\n/**\n * Validate incoming webhook request\n */\nexport function validateWebhookRequest(\n  payload: string, \n  signatureHeader: string | null\n): { valid: boolean; error?: string } {\n  if (!signatureHeader) {\n    return { valid: false, error: 'Missing signature header' };\n  }\n\n  if (!signatureHeader.startsWith('sha256=')) {\n    return { valid: false, error: 'Invalid signature format' };\n  }\n\n  const isValid = verifySignature(payload, signatureHeader);\n  \n  if (!isValid) {\n    return { valid: false, error: 'Invalid signature' };\n  }\n\n  return { valid: true };\n}\n\n/**\n * Generate session-based token for additional security\n */\nexport function generateSessionToken(sessionId: string): string {\n  const timestamp = Date.now().toString();\n  const data = `${sessionId}:${timestamp}`;\n  const signature = crypto\n    .createHmac('sha256', WEBHOOK_SECRET)\n    .update(data, 'utf8')\n    .digest('hex');\n  \n  return `${timestamp}.${signature}`;\n}\n\n/**\n * Verify session token (valid for 1 hour)\n */\nexport function verifySessionToken(sessionId: string, token: string): boolean {\n  try {\n    const [timestamp, signature] = token.split('.');\n    \n    if (!timestamp || !signature) {\n      return false;\n    }\n\n    // Check if token is not older than 1 hour\n    const tokenTime = parseInt(timestamp);\n    const now = Date.now();\n    const oneHour = 60 * 60 * 1000;\n    \n    if (now - tokenTime > oneHour) {\n      return false;\n    }\n\n    // Verify signature\n    const data = `${sessionId}:${timestamp}`;\n    const expectedSignature = crypto\n      .createHmac('sha256', WEBHOOK_SECRET)\n      .update(data, 'utf8')\n      .digest('hex');\n\n    return crypto.timingSafeEqual(\n      Buffer.from(signature, 'hex'),\n      Buffer.from(expectedSignature, 'hex')\n    );\n  } catch (error) {\n    return false;\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAEA,iEAAiE;AACjE,MAAM,iBAAiB,QAAQ,GAAG,CAAC,cAAc,IAAI;AAK9C,SAAS,kBAAkB,OAAe;IAC/C,OAAO,qGAAA,CAAA,UAAM,CACV,UAAU,CAAC,UAAU,gBACrB,MAAM,CAAC,SAAS,QAChB,MAAM,CAAC;AACZ;AAKO,SAAS,gBAAgB,OAAe,EAAE,SAAiB;IAChE,MAAM,oBAAoB,kBAAkB;IAE5C,uDAAuD;IACvD,MAAM,iBAAiB,OAAO,IAAI,CAAC,CAAC,OAAO,EAAE,mBAAmB,EAAE;IAClE,MAAM,eAAe,OAAO,IAAI,CAAC,WAAW;IAE5C,IAAI,eAAe,MAAM,KAAK,aAAa,MAAM,EAAE;QACjD,OAAO;IACT;IAEA,OAAO,qGAAA,CAAA,UAAM,CAAC,eAAe,CAAC,gBAAgB;AAChD;AAKO,SAAS,sBAAsB,OAAe;IACnD,OAAO,CAAC,OAAO,EAAE,kBAAkB,UAAU;AAC/C;AAKO,SAAS,uBACd,OAAe,EACf,eAA8B;IAE9B,IAAI,CAAC,iBAAiB;QACpB,OAAO;YAAE,OAAO;YAAO,OAAO;QAA2B;IAC3D;IAEA,IAAI,CAAC,gBAAgB,UAAU,CAAC,YAAY;QAC1C,OAAO;YAAE,OAAO;YAAO,OAAO;QAA2B;IAC3D;IAEA,MAAM,UAAU,gBAAgB,SAAS;IAEzC,IAAI,CAAC,SAAS;QACZ,OAAO;YAAE,OAAO;YAAO,OAAO;QAAoB;IACpD;IAEA,OAAO;QAAE,OAAO;IAAK;AACvB;AAKO,SAAS,qBAAqB,SAAiB;IACpD,MAAM,YAAY,KAAK,GAAG,GAAG,QAAQ;IACrC,MAAM,OAAO,GAAG,UAAU,CAAC,EAAE,WAAW;IACxC,MAAM,YAAY,qGAAA,CAAA,UAAM,CACrB,UAAU,CAAC,UAAU,gBACrB,MAAM,CAAC,MAAM,QACb,MAAM,CAAC;IAEV,OAAO,GAAG,UAAU,CAAC,EAAE,WAAW;AACpC;AAKO,SAAS,mBAAmB,SAAiB,EAAE,KAAa;IACjE,IAAI;QACF,MAAM,CAAC,WAAW,UAAU,GAAG,MAAM,KAAK,CAAC;QAE3C,IAAI,CAAC,aAAa,CAAC,WAAW;YAC5B,OAAO;QACT;QAEA,0CAA0C;QAC1C,MAAM,YAAY,SAAS;QAC3B,MAAM,MAAM,KAAK,GAAG;QACpB,MAAM,UAAU,KAAK,KAAK;QAE1B,IAAI,MAAM,YAAY,SAAS;YAC7B,OAAO;QACT;QAEA,mBAAmB;QACnB,MAAM,OAAO,GAAG,UAAU,CAAC,EAAE,WAAW;QACxC,MAAM,oBAAoB,qGAAA,CAAA,UAAM,CAC7B,UAAU,CAAC,UAAU,gBACrB,MAAM,CAAC,MAAM,QACb,MAAM,CAAC;QAEV,OAAO,qGAAA,CAAA,UAAM,CAAC,eAAe,CAC3B,OAAO,IAAI,CAAC,WAAW,QACvB,OAAO,IAAI,CAAC,mBAAmB;IAEnC,EAAE,OAAO,OAAO;QACd,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 153, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/phanu/BoomBigNose-n8n%2Bwebiste/BoomBigNose-portfolio/src/app/api/sse/route.ts"],"sourcesContent":["//sse\nimport { NextRequest } from \"next/server\";\n\n// Store for SSE connections\nconst connections = new Map<string, ReadableStreamDefaultController>();\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const sessionId = searchParams.get('sessionId') || Date.now().toString();\n\n    console.log(`SSE connection established for session: ${sessionId}`);\n\n    const stream = new ReadableStream({\n      start(controller) {\n        try {\n          // Store the connection\n          connections.set(sessionId, controller);\n\n          // Send initial connection message\n          controller.enqueue(`data: ${JSON.stringify({\n            type: 'connected',\n            sessionId,\n            message: '‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ AI ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à'\n          })}\\n\\n`);\n\n          console.log(`SSE initial message sent for session: ${sessionId}`);\n\n          // Clean up on close\n          request.signal.addEventListener('abort', () => {\n            console.log(`SSE connection closed for session: ${sessionId}`);\n            connections.delete(sessionId);\n            try {\n              controller.close();\n            } catch (e) {\n              // Connection already closed\n            }\n          });\n        } catch (error) {\n          console.error('Error in SSE stream start:', error);\n          connections.delete(sessionId);\n        }\n      },\n    });\n\n    return new Response(stream, {\n      headers: {\n        'Content-Type': 'text/event-stream',\n        'Cache-Control': 'no-cache',\n        'Connection': 'keep-alive',\n        'Access-Control-Allow-Origin': '*',\n        'Access-Control-Allow-Methods': 'GET',\n        'Access-Control-Allow-Headers': 'Cache-Control',\n        'X-Accel-Buffering': 'no', // Disable nginx buffering\n      },\n    });\n  } catch (error) {\n    console.error('Error in SSE GET handler:', error);\n    return new Response('SSE Error', { status: 500 });\n  }\n}\n\n// Function to send message to specific session\nexport function sendToSession(sessionId: string, data: any) {\n  console.log(`[SSE] Attempting to send to session: ${sessionId}`);\n  console.log(`[SSE] Available connections:`, Array.from(connections.keys()));\n  console.log(`[SSE] Total connections: ${connections.size}`);\n\n  const controller = connections.get(sessionId);\n  if (controller) {\n    try {\n      controller.enqueue(`data: ${JSON.stringify(data)}\\n\\n`);\n      console.log(`[SSE] Successfully sent message to session: ${sessionId}`);\n      return true;\n    } catch (error) {\n      console.error(`[SSE] Error sending to session ${sessionId}:`, error);\n      connections.delete(sessionId);\n      return false;\n    }\n  } else {\n    console.log(`[SSE] No connection found for session: ${sessionId}`);\n    console.log(`[SSE] Searching for partial matches...`);\n\n    // Try to find partial matches in case of session ID mismatch\n    for (const [connId, controller] of connections.entries()) {\n      if (connId.includes(sessionId) || sessionId.includes(connId)) {\n        console.log(`[SSE] Found partial match: ${connId} for ${sessionId}`);\n        try {\n          controller.enqueue(`data: ${JSON.stringify(data)}\\n\\n`);\n          console.log(`[SSE] Successfully sent message to partial match: ${connId}`);\n          return true;\n        } catch (error) {\n          console.error(`[SSE] Error sending to partial match ${connId}:`, error);\n          connections.delete(connId);\n        }\n      }\n    }\n  }\n  return false;\n}\n\n// Function to broadcast to all connections\nexport function broadcast(data: any) {\n  let sent = 0;\n  for (const [sessionId, controller] of connections.entries()) {\n    try {\n      controller.enqueue(`data: ${JSON.stringify(data)}\\n\\n`);\n      sent++;\n    } catch (error) {\n      console.error('Error broadcasting to session:', sessionId, error);\n      connections.delete(sessionId);\n    }\n  }\n  return sent;\n}\n\n// Function to get connection info for debugging\nexport function getConnectionInfo() {\n  return {\n    totalConnections: connections.size,\n    sessionIds: Array.from(connections.keys())\n  };\n}\n\n// Add a POST endpoint for debugging SSE connections\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { action, sessionId, testData } = body;\n\n    if (action === 'debug') {\n      const info = getConnectionInfo();\n      console.log(`[SSE Debug] Connection info:`, info);\n      return new Response(JSON.stringify({\n        success: true,\n        connectionInfo: info,\n        timestamp: new Date().toISOString()\n      }), {\n        headers: { 'Content-Type': 'application/json' }\n      });\n    }\n\n    if (action === 'test' && sessionId) {\n      const testMessage = testData || { type: 'test', message: 'Test message from debug endpoint' };\n      const sent = sendToSession(sessionId, testMessage);\n      return new Response(JSON.stringify({\n        success: sent,\n        message: sent ? 'Test message sent successfully' : 'Failed to send test message',\n        sessionId,\n        connectionInfo: getConnectionInfo()\n      }), {\n        headers: { 'Content-Type': 'application/json' }\n      });\n    }\n\n    return new Response(JSON.stringify({\n      error: 'Invalid action. Use \"debug\" or \"test\"'\n    }), {\n      status: 400,\n      headers: { 'Content-Type': 'application/json' }\n    });\n\n  } catch (error) {\n    console.error('SSE POST error:', error);\n    return new Response(JSON.stringify({\n      error: 'Failed to process request'\n    }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' }\n    });\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 328, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/phanu/BoomBigNose-n8n%2Bwebiste/BoomBigNose-portfolio/src/app/api/chatreport/route.ts"],"sourcesContent":["//chatreport\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { createSignatureHeader, generateSessionToken } from \"@/lib/webhook-security\";\nimport { sendToSession } from \"@/app/api/sse/route\";\n\nconst portfolioData = {\n  name: \"NIS Automation Service (Instrument)\",\n  title: \"‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡∏µ‡πà‡∏¢‡∏ß‡∏ä‡∏≤‡∏ç‡∏ó‡∏µ‡πà‡πÉ‡∏´‡πâ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö ‡∏ã‡πà‡∏≠‡∏°‡∏ö‡∏≥‡∏£‡∏∏‡∏á ‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏≠‡∏∏‡∏ï‡∏™‡∏≤‡∏´‡∏Å‡∏£‡∏£‡∏°\",\n  contact: {\n    phone: \"(+66) 85-835-1266\",\n    email: \"Phanupong_C@npp.co.th\",\n    address: \"1 tatoom, Srimahapot, Prachin buri 25140, Thailand\"\n  },\n  summary: \"‡πÄ‡∏£‡∏≤‡∏Ñ‡∏∑‡∏≠‡∏ó‡∏µ‡∏°‡∏ú‡∏π‡πâ‡πÄ‡∏ä‡∏µ‡πà‡∏¢‡∏ß‡∏ä‡∏≤‡∏ç‡∏ó‡∏µ‡πà‡πÉ‡∏´‡πâ‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö ‡∏ã‡πà‡∏≠‡∏°‡∏ö‡∏≥‡∏£‡∏∏‡∏á ‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡∏≠‡∏∏‡∏ï‡∏™‡∏≤‡∏´‡∏Å‡∏£‡∏£‡∏° ‡πÄ‡∏ä‡πà‡∏ô ‡∏ß‡∏≤‡∏•‡πå‡∏ß (Control Valve), ‡πÄ‡∏ã‡∏ü‡∏ï‡∏µ‡πâ‡∏ß‡∏≤‡∏•‡πå‡∏ß (Safety Valve), ‡πÅ‡∏ó‡πà‡∏ô‡∏ä‡∏±‡πà‡∏á‡∏î‡∏¥‡∏à‡∏¥‡∏ó‡∏±‡∏• (Weight Scale) ‡πÅ‡∏•‡∏∞‡∏£‡∏∞‡∏ö‡∏ö‡∏ß‡∏±‡∏î‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡∏Å‡∏≤‡∏£‡πÑ‡∏´‡∏• (Flow Measurement System) ‡∏î‡πâ‡∏ß‡∏¢‡∏õ‡∏£‡∏∞‡∏™‡∏ö‡∏Å‡∏≤‡∏£‡∏ì‡πå‡πÅ‡∏•‡∏∞‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á ‡πÄ‡∏£‡∏≤‡∏°‡∏∏‡πà‡∏á‡πÄ‡∏ô‡πâ‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û ‡πÅ‡∏•‡∏∞‡∏¢‡∏∑‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏±‡∏Å‡∏£\"\n};\n\nexport async function POST(req: NextRequest) {\n  let userMessage = \"\";\n  let sessionId = \"\";\n\n  try {\n    const { message, history, sessionId: clientSessionId } = await req.json();\n    userMessage = message || \"\";\n    sessionId = clientSessionId || `session_${Date.now()}`;\n\n    if (!userMessage) {\n      return NextResponse.json({ error: \"Message is required\" }, { status: 400 });\n    }\n\n    console.log(`[Chatreport API] Session: ${sessionId}, Message: ${userMessage.substring(0, 50)}...`);\n\n    // üî• ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å webhook n8n\n    try {\n      const payload = JSON.stringify({\n        message: userMessage,\n        history,\n        portfolioData,\n        sessionId,\n        sessionToken: generateSessionToken(sessionId),\n        timestamp: new Date().toISOString()\n      });\n\n      const signature = createSignatureHeader(payload);\n\n      const webhookResponse = await fetch(\"http://localhost:5678/webhook-test/8bdc9363-b386-44cb-a05c-cd168d0f8608\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"x-session-id\": sessionId,\n          \"x-webhook-source\": \"portfolio-chat\",\n          \"x-signature\": signature,\n        },\n        body: payload,\n        signal: AbortSignal.timeout(15000)\n      });\n\n      if (webhookResponse.ok) {\n        const webhookData = await webhookResponse.json();\n        console.log(`[Chatreport API] Webhook success:`, webhookData);\n\n        // üî• ‡∏ñ‡πâ‡∏≤ workflow ‡∏à‡∏∞‡∏ï‡∏≠‡∏ö‡∏ú‡πà‡∏≤‡∏ô SSE\n        if (webhookData.useSSE || webhookData.async || webhookData.status === 'processing' ||\n          (webhookData.message && webhookData.message.includes('Workflow was started'))) {\n          console.log(`[Chatreport API] Waiting SSE mode for session: ${sessionId}`);\n          return NextResponse.json({\n            success: true,\n            useSSE: true,\n            sessionId,\n            message: \"Response will be sent via SSE\"\n          });\n        }\n\n        // üî• immediate response mode\n        let responseMessage = \"\";\n        if (typeof webhookData === 'string') {\n          responseMessage = webhookData;\n        } else if (webhookData.response) {\n          responseMessage = webhookData.response;\n        } else if (webhookData.message) {\n          responseMessage = webhookData.message;\n        } else if (webhookData.reply) {\n          responseMessage = webhookData.reply;\n        } else if (webhookData.text) {\n          responseMessage = webhookData.text;\n        } else {\n          console.log(`[Chatreport API] Unexpected format:`, webhookData);\n          throw new Error(\"Unexpected webhook response format\");\n        }\n\n        // üî• ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏™‡πà‡∏á‡∏ú‡πà‡∏≤‡∏ô SSE ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ fallback HTTP\n        const success = sendToSession(sessionId, {\n          type: \"response\",\n          message: responseMessage\n        });\n\n        if (!success) {\n          console.log(`[Fallback] SSE not found, send via HTTP`);\n          return NextResponse.json({\n            message: responseMessage,\n            useSSE: false\n          });\n        }\n\n        return NextResponse.json({\n          success: true,\n          message: responseMessage,\n          useSSE: false\n        });\n\n      } else {\n        const errorText = await webhookResponse.text();\n        console.log(`[Chatreport API] Webhook error ${webhookResponse.status}:`, errorText);\n        throw new Error(`Webhook returned status: ${webhookResponse.status}`);\n      }\n\n    } catch (webhookError) {\n      console.log(`[Chatreport API] Webhook failed:`, webhookError);\n      const response = generateResponse(userMessage.toLowerCase());\n      return NextResponse.json({\n        message: response,\n        useSSE: false,\n        fallback: true\n      });\n    }\n\n  } catch (error) {\n    console.error(`[Chatreport API] Fatal error:`, error);\n    const response = generateResponse(userMessage.toLowerCase() || \"\");\n    return NextResponse.json({\n      message: response,\n      useSSE: false,\n      fallback: true,\n      error: \"System temporarily unavailable\"\n    });\n  }\n}\n\n// üî• function ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö fallback message\nfunction generateResponse(message: string): string {\n  if (message.includes(\"skill\") || message.includes(\"‡∏ó‡∏±‡∏Å‡∏©‡∏∞\") || message.includes(\"‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£\")) {\n    return `‡∏ó‡∏µ‡∏° Instrument service ‡∏°‡∏µ‡∏ó‡∏±‡∏Å‡∏©‡∏∞‡πÉ‡∏ô‡∏á‡∏≤‡∏ô Maintenance ‡πÄ‡∏ä‡πà‡∏ô:\n    üîß ‡πÇ‡∏ó‡∏£: ${portfolioData.contact.phone},\n    üíß ‡∏≠‡∏µ‡πÄ‡∏°‡∏•: ${portfolioData.contact.email},\n    ‚öñÔ∏è ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà: ${portfolioData.contact.address}`;\n  }\n  return `‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏Ñ‡∏£‡∏±‡∏ö! ‡∏´‡∏≤‡∏Å‡∏™‡∏ô‡πÉ‡∏à‡∏ã‡πà‡∏≠‡∏°‡∏ö‡∏≥‡∏£‡∏∏‡∏á ‡∏ß‡∏≤‡∏•‡πå‡∏ß ‡πÅ‡∏ó‡πà‡∏ô‡∏ä‡∏±‡πà‡∏á IoT ‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡πÄ‡∏£‡∏≤‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢:\n    üìß ${portfolioData.contact.email} üì± ${portfolioData.contact.phone}`;\n}\n"],"names":[],"mappings":"AAAA,YAAY;;;;AACZ;AACA;AACA;;;;AAEA,MAAM,gBAAgB;IACpB,MAAM;IACN,OAAO;IACP,SAAS;QACP,OAAO;QACP,OAAO;QACP,SAAS;IACX;IACA,SAAS;AACX;AAEO,eAAe,KAAK,GAAgB;IACzC,IAAI,cAAc;IAClB,IAAI,YAAY;IAEhB,IAAI;QACF,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,WAAW,eAAe,EAAE,GAAG,MAAM,IAAI,IAAI;QACvE,cAAc,WAAW;QACzB,YAAY,mBAAmB,CAAC,QAAQ,EAAE,KAAK,GAAG,IAAI;QAEtD,IAAI,CAAC,aAAa;YAChB,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAsB,GAAG;gBAAE,QAAQ;YAAI;QAC3E;QAEA,QAAQ,GAAG,CAAC,CAAC,0BAA0B,EAAE,UAAU,WAAW,EAAE,YAAY,SAAS,CAAC,GAAG,IAAI,GAAG,CAAC;QAEjG,uBAAuB;QACvB,IAAI;YACF,MAAM,UAAU,KAAK,SAAS,CAAC;gBAC7B,SAAS;gBACT;gBACA;gBACA;gBACA,cAAc,CAAA,GAAA,mIAAA,CAAA,uBAAoB,AAAD,EAAE;gBACnC,WAAW,IAAI,OAAO,WAAW;YACnC;YAEA,MAAM,YAAY,CAAA,GAAA,mIAAA,CAAA,wBAAqB,AAAD,EAAE;YAExC,MAAM,kBAAkB,MAAM,MAAM,2EAA2E;gBAC7G,QAAQ;gBACR,SAAS;oBACP,gBAAgB;oBAChB,gBAAgB;oBAChB,oBAAoB;oBACpB,eAAe;gBACjB;gBACA,MAAM;gBACN,QAAQ,YAAY,OAAO,CAAC;YAC9B;YAEA,IAAI,gBAAgB,EAAE,EAAE;gBACtB,MAAM,cAAc,MAAM,gBAAgB,IAAI;gBAC9C,QAAQ,GAAG,CAAC,CAAC,iCAAiC,CAAC,EAAE;gBAEjD,gCAAgC;gBAChC,IAAI,YAAY,MAAM,IAAI,YAAY,KAAK,IAAI,YAAY,MAAM,KAAK,gBACnE,YAAY,OAAO,IAAI,YAAY,OAAO,CAAC,QAAQ,CAAC,yBAA0B;oBAC/E,QAAQ,GAAG,CAAC,CAAC,+CAA+C,EAAE,WAAW;oBACzE,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;wBACvB,SAAS;wBACT,QAAQ;wBACR;wBACA,SAAS;oBACX;gBACF;gBAEA,6BAA6B;gBAC7B,IAAI,kBAAkB;gBACtB,IAAI,OAAO,gBAAgB,UAAU;oBACnC,kBAAkB;gBACpB,OAAO,IAAI,YAAY,QAAQ,EAAE;oBAC/B,kBAAkB,YAAY,QAAQ;gBACxC,OAAO,IAAI,YAAY,OAAO,EAAE;oBAC9B,kBAAkB,YAAY,OAAO;gBACvC,OAAO,IAAI,YAAY,KAAK,EAAE;oBAC5B,kBAAkB,YAAY,KAAK;gBACrC,OAAO,IAAI,YAAY,IAAI,EAAE;oBAC3B,kBAAkB,YAAY,IAAI;gBACpC,OAAO;oBACL,QAAQ,GAAG,CAAC,CAAC,mCAAmC,CAAC,EAAE;oBACnD,MAAM,IAAI,MAAM;gBAClB;gBAEA,+CAA+C;gBAC/C,MAAM,UAAU,CAAA,GAAA,mIAAA,CAAA,gBAAa,AAAD,EAAE,WAAW;oBACvC,MAAM;oBACN,SAAS;gBACX;gBAEA,IAAI,CAAC,SAAS;oBACZ,QAAQ,GAAG,CAAC,CAAC,uCAAuC,CAAC;oBACrD,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;wBACvB,SAAS;wBACT,QAAQ;oBACV;gBACF;gBAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;oBACvB,SAAS;oBACT,SAAS;oBACT,QAAQ;gBACV;YAEF,OAAO;gBACL,MAAM,YAAY,MAAM,gBAAgB,IAAI;gBAC5C,QAAQ,GAAG,CAAC,CAAC,+BAA+B,EAAE,gBAAgB,MAAM,CAAC,CAAC,CAAC,EAAE;gBACzE,MAAM,IAAI,MAAM,CAAC,yBAAyB,EAAE,gBAAgB,MAAM,EAAE;YACtE;QAEF,EAAE,OAAO,cAAc;YACrB,QAAQ,GAAG,CAAC,CAAC,gCAAgC,CAAC,EAAE;YAChD,MAAM,WAAW,iBAAiB,YAAY,WAAW;YACzD,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBACvB,SAAS;gBACT,QAAQ;gBACR,UAAU;YACZ;QACF;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,CAAC,6BAA6B,CAAC,EAAE;QAC/C,MAAM,WAAW,iBAAiB,YAAY,WAAW,MAAM;QAC/D,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,QAAQ;YACR,UAAU;YACV,OAAO;QACT;IACF;AACF;AAEA,sCAAsC;AACtC,SAAS,iBAAiB,OAAe;IACvC,IAAI,QAAQ,QAAQ,CAAC,YAAY,QAAQ,QAAQ,CAAC,YAAY,QAAQ,QAAQ,CAAC,WAAW;QACxF,OAAO,CAAC;YACA,EAAE,cAAc,OAAO,CAAC,KAAK,CAAC;cAC5B,EAAE,cAAc,OAAO,CAAC,KAAK,CAAC;gBAC5B,EAAE,cAAc,OAAO,CAAC,OAAO,EAAE;IAC/C;IACA,OAAO,CAAC;OACH,EAAE,cAAc,OAAO,CAAC,KAAK,CAAC,IAAI,EAAE,cAAc,OAAO,CAAC,KAAK,EAAE;AACxE","debugId":null}}]
}